% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_SpatioTemporal.R,
%   R/cluster_SpatioTemporal_Rjulia.R
\name{cluster_SpatioTemporal}
\alias{cluster_SpatioTemporal}
\alias{cluster_SpatioTemporal_julia}
\alias{cluster_SpatioTemporal_R}
\title{cluster_SpatioTemporal}
\usage{
cluster_SpatioTemporal(
  arr,
  cellCoor = NULL,
  ncell_connect = 1L,
  ncell_overlap = 1L,
  factor = 10000,
  diag = FALSE
)

cluster_SpatioTemporal_julia(
  arr,
  method = "tree",
  ncell_connect = 1L,
  ncell_overlap = 5L,
  factor = 10000,
  diag = FALSE,
  ...
)

cluster_SpatioTemporal_R(
  arr,
  ncell_connect = 1,
  ncell_overlap = 5,
  factor = 10000,
  diag = FALSE,
  verbose = TRUE,
  version = c("julia", "fortran"),
  .parallel = FALSE,
  nodes = 16,
  ...
)
}
\arguments{
\item{arr}{a three-dimensional array including only TRUE and FALSE.}

\item{cellCoor}{integer matrix, \verb{[nCells, 2]}}

\item{ncell_connect}{a integer. If a cluster with number of grids is no more
than this threshold, this cluster will be excluded.}

\item{ncell_overlap}{a integer. If the share grids of the two clusters in two
consecutive layers are no less than the overlap, the two clusters will be
taken as the same one.}

\item{factor}{a integer that is used to recode cluster encoding.}

\item{diag}{a logical value. If TRUE, the diagonal grids are taken as
the adjacent congeneric grids.}

\item{method}{one of "tree", "recursive" and "low". "tree" is the default and
the fastest. The second fastest is "recursive".}

\item{verbose}{a logical value. If TRUE, the cluster translation process will
be printed.}

\item{nodes}{a integer. The number of cluster will be opened for parallel
calculation.}
}
\value{
\itemize{
\item clusterId: with the same dimension as arr
}
}
\description{
cluster drought clusters in space and time

Connect clusters in space and time
}
\examples{
set.seed(1)

nlon <- 10
nlat <- 10
ngrid <- nlon*nlat
ntime <- 12
dim = c(nlon, nlat, ntime)
threshold = 0.2
 
arr <- array(rnorm(nlon*nlat*ntime), dim = c(nlon, nlat, ntime)) > 0.2 # boolean arr
# mask = apply_3d(arr >= 0.2, FUN = rowSums2) > 0
# r  <- droughtIndicator( arr, mask, threshold = 0.2)
r_cluster <- cluster_SpatioTemporal(arr, ncell_connect = 1, ncell_overlap = 1, factor = 1000)
plot.cluster(r_cluster)
# r_status  <- ClusterStats(mat, mask, SMI_thld, r_cluster$clusterId, r_cluster$shortCnoList)

ndim <- 10
ntime = 4
arr <- array(data = ifelse(sample(1:100, 20^2*20, T) > 50, T, F), c(ndim, ndim, ntime))
z1 <- cluster_SpatioTemporal(arr, ncell_connect = 5, ncell_overlap = 5, factor = 100)

z2 <- cluster_SpatioTemporal_julia(arr, method = 'tree', ncell_connect = 5, ncell_overlap = 5)
z3 <- cluster_SpatioTemporal_julia(arr, method = 'recursive', ncell_connect = 5, ncell_overlap = 5)
z4 <- cluster_SpatioTemporal_julia(arr, method = 'low', ncell_connect = 5, ncell_overlap = 5)

z5 <- cluster_SpatioTemporal_R(arr, version = 'julia', ncell_connect = 5, ncell_overlap = 5, factor = 100)
z6 <- cluster_SpatioTemporal_R(arr, version = 'fortran', ncell_connect = 5, ncell_overlap = 5, factor = 100)

# cluster_grids(z6)
all.equal(cluster_grids(z2), cluster_grids(z3))
all.equal(cluster_grids(z2), cluster_grids(z4))
all.equal(cluster_grids(z2), cluster_grids(z1))
all.equal(cluster_grids(z5), cluster_grids(z6))
all.equal(cluster_grids(z1), cluster_grids(z5))
}
\author{
Dongdong Kong, 2021-05-29
}
